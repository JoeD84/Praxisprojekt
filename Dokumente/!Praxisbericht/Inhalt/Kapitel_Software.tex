\chapter{Software}
\label{cha:Software}
\todo{Einführung schreiben}
\todo{Weitere Software in Begriffen erklären. Minolta}

\section{RapidForm2004}
\label{sec:RapidForm}
Zur Erfassung von 3D-Modellen am PC steht die Software RapidForm2004 der Firma INUS Technology Inc. zur Verfügung. Diese ist zur Erfassung und Bearbeitung von 3D-Modellen gedacht. Sie bietet umfangreiche Möglichkeiten die aufgenommenen Modelle zu verbessern, zu verändern, zu vermessen und in verschiedene Formate zu exportieren.\\
Die Ansteuerung des VI-900 ist durch ein \Fachbegriff{Add-In} bereits in die Software integriert. Das Add-In kann den VI-900 ansteuern und die aufgenommenen Daten auslesen. Weiterhin kann das Add-In verschiedene Drehtische ansteuern.

\section{Entwicklungsumgebung}
\label{sec:Entwicklungsumgebung}
Als Entwicklungsumgebung wird eine Software bezeichnet die es dem Anwender erleichtert Programme für den Mikrocontroller zu schreiben. Im allgemeinen bestehen Entwicklungsumgebungen aus einem Editor, dem Compiler und einer Programmiersoftware. Der Editor bietet dabei meist Komfortfunktionen wie \Fachbegriff{Syntaxhighlighting}, Autovervollständigung und Projektmanagement.
\subsection{AVR Studio 5}
Zu Beginn nutzte ich die von Atmel bereitgestellte Entwicklungsumgebung. Diese scheint jedoch eine fehlerhafte Bibliothek zu enthalten. Die Kombination aus Mikrocontroller ATmega324A und AVR Studio 5 erzeugte nicht nachvollziehbare Probleme. Bei dem selbem Programm und einem anderem Mikrocontroller oder einer anderen Entwicklungsumgebung tauchten keine Fehler auf.
In der Entwicklungsumgebung Eclipse lies sich der Fehler reproduzieren wenn der Pfad der Atmel Bibliotheken eingestellt wurde. Die WinAVR Bibliotheken und eine selbst kompilierte \Fachbegriff{Toolchain} unter Linux zeigten keine Probleme.\\
Daher wechselte ich zur \Fachbegriff{Open Source} Entwicklungsumgebung Eclipse. Erst dadurch wurde es möglich erfolgreich zu arbeiten. Außerdem wurde das Projekt dadurch plattformunabhänig und ich nutzte bis auf RapidForm2004 nur noch freie Open Source Software.\\
\subsection{Eclipse}
Eclipse ist eine in Java programmierte freie Open Source Entwicklungsumgebung für Java. Sie lässt sich durch \Fachbegriff{Plugins} leicht für viele Sprachen erweitern.\\
Mit dem CDT-Plugin, dem AVR-Plugin und einer Bibliothek wie z.B. WinAVR für Windows ist Eclipse eine vollwertige Entwicklungsumgebung für Atmel Mikrocontroller. 
Ergänzt wird diese durch die Programmiersoftware AVR-Dude.\\
\section{Mikrocontroller}
In diesem Kapitel werde ich einzelne Abschnitte des von mir geschriebenen Programms beschreiben und erklären. 
Dabei gliedert sich das Kapitel in folgende Unterkapitel:
\begin{itemize}
\item \ref{sec:Fuses} Fuses
\item \ref{sec:LEDs} LEDs
\item \ref{sec:Taster} Taster
\item \ref{sec:LCD-Bibliothek} LCD-Bibliothek
\item \ref{sec:RS-232} RS-232 Schnittstelle 
\item \ref{sec:Menu} Menü-Bibliothek
\end{itemize}

Die Codebeispiele sind dabei thematisch zusammen gefasst und gekürzt um die Lesbarkeit zu gewährleisten.
Ein komplettes Codelisting der \Fachbegriff{main.c} befindet sich im Anhang. Der komplette Code, mit allen Bibliotheken, liegt dem Praxisbericht als CD oder Archiv bei. 
\todo{Backup anlegen und cleanen!}
\subsection{Fuses}
\label{sec:Fuses}
Als Fuses werden Register bezeichnet mit denen sich, auf Hardwareebene, das Verhalten des Mikrocontrollers verändern lässt. \\
Im Projekt wurden folgende Fuses problematisch.
\begin{itemize}
\item \textbf{JTAGEN} - Ist dieses \Fachbegriff{Fusebit} gesetzt, werden 4 Pins des PortB genutzt um den Mikrocontroller zu debuggen und können nicht anders genutzt werden. Hardware Debugging bietet viele Vorteile. Diese wurden im Projekt jedoch nicht genutzt da PortB für die LEDs genutzt wurde.
\item \textbf{WDTON} - Ist dieses Fusebit gesetzt läuft der Watchdog Timer immer mit. Wird der Watchdog dann nicht regelmäßig zurückgesetzt startet der Mikrocontroller ständig neu.
\item \textbf{CKDIV8} - Teilt den Systemtakt des Mikrocontroller durch 8. Dies ist Energiesparender. Der geringere Takt muss in F\_CPU angepasst werden da sonst zeitkritische Prozesse mit der falschen Geschwindigkeit ablaufen.
\item \textbf{CKOUT} - An PortB wird an einem Pin der Systemtakt ausgegeben. Dieser kann dann leicht mit einem Frequenz-Messgerät überprüft werden. Der Pin kann dann jedoch nicht anderweitig genutzt werden.
\item \textbf{CKSELX} - Über diese 4 Bits kann der Systemtakt eingestellt werden.
\end{itemize}
\begin{longtable}{|c|l|} 
\caption{Fuses} \\
\hline
\label{tab:TD_VI-910}
OCDEN & On Chip Debugging \\ \hline 
JTAGEN & Hardware Debugging \\ \hline 
SPIEN & Serial Program and Data Downloading \\ \hline 
WDTON & Watchdot Timer always on \\ \hline 
EESAVE & EEPROM memory is preserved through the Chip Erase \\ \hline 
BOOTSZ1 & Select Boot Size \\ \hline 
BOOTSZ0 & Select Boot Size \\ \hline 
BOOTRST & Select Reset Vector \\ \hline 
CKDIV8 & Divide clock by 8 \\ \hline 
CKOUT & Clock output \\ \hline 
SUT1 & Select start-up time \\ \hline 
SUT0 & Select start-up time \\ \hline 
CKSEL3 & Select Clock source \\ \hline 
CKSEL2 & Select Clock source \\ \hline 
CKSEL1 & Select Clock source \\ \hline 
CKSEL0 & Select Clock source \\ \hline 
\end{longtable} 



\subsection{LEDs}
Das Codebeispiel \ref{lst:Lauflicht} zeigt ein einfaches Beispiel mit dem sich die Funktionalität der LEDs leicht überprüfen lässt. Bei jedem Aufruf der Funktion wird der aktuelle Status des LED Port abgefragt und der Hexwert um 1 Bit verschoben. Dadurch wird die daneben liegende LED eingeschaltet und die aktuelle aus geschaltet. Wird ein bestimmter Wert überschritten wird der Port wieder auf den Anfangszustand zurück gesetzt.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=2}
\lstinputlisting[label=lst:Lauflicht,caption=Funktion: Lauflicht]{Code/led_lauflicht_sample.txt}
\subsection{Taster}
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=2}
\lstinputlisting[label=lst:Taster,caption=Taster]{Code/taster.txt}


\subsection{LCD Bibliothek}
Die meisten LC-Displays werden auf die selbe Art angesteuert. Hier gibt es fertige Bibliotheken die frei genutzt werden können. Im Projekt wird die von Peter Fleury\cite{uC:Fleury} verwendet.\\
Dazu müssen die Dateien lcd.c und lcd.h in das Arbeitsverzeichnis kopiert werden und die Bibliothek mit \emph{\#include(lcd.h)} eingebunden werden. \\
Anschließend müssen noch in der lcd.h die Daten des Display eingegeben werden.
Danach kann das Display mit den Befehlen aus Zeile 15-24 aus dem Codebeispiel \ref{lst:LCD_Def} angesteuert werden.

\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=4}
\lstinputlisting[label=lst:LCD_Def,caption=Definitionen: LCD]{Code/lcd_def.txt}
\subsection{RS-232}
\Fachbegriff{RS-232} ist der Name der am meisten verwendeten seriellen asynchronen Schnittstelle, im Fachjargon auch Übertragungsstandard genannt, um Daten zwischen zwei elektronischen Geräten hin und her zu schicken (im Fachjargon: Datenkommunikation).\cite{uC:rs232}\\
Eine serielle Schnittstelle ist auf dem STK500 vorbereitet. Eine weitere wurde auf einem Steckbrett vorbereitet und mit dem STK500 verbunden.\\
Um die Schnittstellen im Mikrocontroller nutzen zu können wird in Listing \ref{lst:RS232} - Zeile 2 die setbaud.h eingebunden. Zuvor muss noch die Baudrate gesetzt werden.
In der Funktion  werden die entsprechenden Register im Mikrocontroller gesetzt um die Schnittstellen zu konfigurieren.\\
Anschließend kann mit der Funktionen uart\_put\_string() eine Zeichenkette versendet werden. Dabei kann mit der Variable \emph{dir} die Schnittstelle ausgewählt werden über die gesendet werden soll.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=2}
\lstinputlisting[label=lst:RS232,caption=RS-232]{Code/rs232.txt}
\subsection{Menü Bibliothek}
Der Drehtisch kann Manuell über Taster am Einschub bedient werden. Die Menü Bibliothek gestaltet dies einfach und Komfortabel. Mit den Tasten Zurück. Select, Hoch und Runter lässt sich durch die Einzelnen Menü Punkte Navigieren. \todo{Ref! Einbinden erläutern!}
\todo{Menü Baum erstellen!}
\subsection{Interrupts}
\label{sec:Interrupts}
Viele Mikrocontroller bieten die Möglichkeit zeitkritische Subroutinen auszuführen. Wenn einer der Interrupts ausgelöst wird, wird das Hauptprogramm unterbrochen und die Entsprechende Interrupt-Service-Routine ausgeführt. Nach Beendigung der ISR wird das Hauptprogramm an der vorherigen Stelle wieder aufgenommen.\\
ISR dürfen nur sehr wenige Befehle enthalten und müssen innerhalb weniger ClockCicles abgeschlossen sein. \\
Interrupts können z.B. der Überlauf eines internen Timer sein, oder ein externens Signal an einem Pin.\\
Im Projekt werden externe Interrupts, Timer-Überlauf Interrupts und der Watchdog Interrupt genutzt. 
\subsubsection{Endschalter}
Die Endschalter sind über die Schrittmotorkarten und eine Brücke in der Steuerung mit der Mikrocontroller Platine Verbunden. Dort sind sie an 2 Interrupt Pins angeschlossen. \todo{Pins raus suchen!} Bei einem Flanken Wechsel an den Pins wird ein Interrupt ausgelöst. \\
Das Code-Listing \ref{lst:ISR_ES} zeigt die ISR für die Endschalter.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=2}
\lstinputlisting[label=lst:ISR_ES,caption=ISR: Endschalter]{Code/ISR_Endschalter.txt}
\subsubsection{Watchdog}
Der \Fachbegriff{Watchdog} ist eine Sicherungseinrichtung des Mikrocontroller. In regelmäßigen Abständen wird überprüft ob das Watchdog Bit gesetzt ist und anschließend zurück gesetzt. Das Bit muss innerhalb der voreingestellten Zeit immer wieder neu gesetzt werden. Dies kann mit der wdt\_reset() Funktion realisiert werden. Ist das Bit nicht gesetzt, wird der Mikrocontroller zurückgesetzt. \todo{Inverse Logik?} Dies geschieht z.B. bei nicht geplanten Endlosschleifen.\\
Wahlweise kann kurz vor dem Reset noch die Watchdog-ISR durchlaufen werden.\\
Im Projekt wird in der ISR die Fehler LED eingeschaltet und eine Meldung auf dem LC-Display ausgegeben. Siehe hierzu auch Listing \ref{lst:Watchdog} Zeilen 12-15.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=4}
\lstinputlisting[label=lst:Watchdog,caption=Watchdog]{Code/Watchdog.txt}
\subsection{Protokoll der Schrittmotorkarte}
Tabelle \ref{tbl:ASCII_RS} zeigt den ASCII Befehlssatz der Schrittmotorkarte.
\label{sec:A_ASCII_Befehle}
\begin{table}[htb]
\begin{tabular}{|l|l|}	\hline 
\rule[-1ex]{0pt}{2.5ex} \_A 		& Motorstatus liefern                          \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_C n		& konstante Geschwindigkeit einstellen         \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_D n 		& Bezugswert definieren                        \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_E n		& Motorstrom einstellen                        \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_F 		& Standardeinstellungen aktivieren             \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_H 		& Sanfter stop                                 \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_I 		& 4-Bit-Eingang lesen                          \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_J jdss 	& Joystickparameter einstellen                 \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_L n 		& lokalen Modus aktivieren/beenden             \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_M n 		& n Schritte ausführen                         \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_MA n 		& zu n bewegen                                 \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_MC n 		& mit konstanter Geschwindigkeit bewegen       \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_MCA n 	& MA mit konstanter Geschwindigkeit            \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_MCL n 	& MC zu Endschalterposition                    \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_ML n 		& zur Endschalterposition bewegen              \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_N n 		& Zeilenvorschub (LF, hex. 0A) einfügen/löschen\\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_O n 		& n an 4-Bit-Ausgang senden                    \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_P nnnn 	& Motorparameter einstellen                    \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_Q 		& Parameter in EEROM speichern                 \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_R n 		& Mikroschritteilung einstellen                \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_RL 		& Endschalterwerte lesen                       \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_RS  		& verbleibende Schritte lesen                  \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_S   		& Nothalt                                      \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_T n 		& Eingang n auslösen                           \\ \hline 
\rule[-1ex]{0pt}{2.5ex} \_W   		& Position anfordern                           \\ \hline 
\end{tabular} 
\caption{ASCII Befehlssatz R+S Schrittmotorsteuerung}\cite{rs:ug_stepper}
Der ''\_''  wird mit der anzusteuernden Kartennummer ersetzt. Dabei wird von 1 aufwärts gezählt. Bei der ersten Karte kann die Nummer weggelassen werden.
\label{tbl:ASCII_RS}
\end{table}
\subsection{Manueller Betrieb}
\subsection{Protokolle aus RapidForm}
Die Protokolle die RapidForm nutzt um mit den Schrittmotoren zu kommunizieren können leicht mit der Software \todo{Name} abgehört werden. Dies hat jedoch den Nachteil das RapidForm erst den nächsten Befehl sendet wenn der erste richtig quittiert wurde. Die Befehle die RapidForm erwartet konnten aus den Betriebsanleitungen der Schrittmotoren entnommen werden. Dies war jedoch auch nicht immer leicht.\\
Durch \Fachbegriff{Reverse-Engineering} konnten alle Befehle und der Antwort die darauf erwartet wird, aus der Executebale ausgelesen werden. Listing \ref{lst:Proto_RF_Zeta} zeigt einen Auszug für das Protokoll eines Zeta Schrittmotors. Im Anhang befinden sich alle Protokolle.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=8}
\lstinputlisting[label=lst:Proto_RF_Zeta,caption=Protokoll aus Rapidform: Zeta]{Code/Protokolle_RF_Zeta.txt}
\subsection{Übersetzungs Logik}
Das Herzstück der Übersetzungs Software. Für jedes Protokoll muss eine eigene Auswerte Logik geschrieben werden. 
\subsubsection{FindStringInArray Funktion}
Zuerst wird eine Auswerte Logik geschrieben die ankommende Strings mit einem übergebenen Array vergleicht und die Arrayposition übergibt. Diese numerische Rückgabe kann dann mittels einer switch/case Struktur ausgewertet werden.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=8}
\lstinputlisting[label=lst:FindString,caption=Funktion: FindStringInArray]{Code/FindString.c}
\subsubsection{Automatische Protokollwahl}
Nicht jede Software unterstützt alle Protokolle. Daher wurden alle Protokolle realisiert. Um automatisch fest zu stellen welches Protokoll verwendet wird, wird der erste ankommende Befehl gegen die Initialisierungssequenz der Protokolle geprüft und in einer globalen Variable gespeichert.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=8}
\lstinputlisting[label=lst:switchMotor,caption=Funktion: switchMotor]{Code/switch_Motor.c}
\subsubsection{Zeta}
Zeta
\subsubsection{Isel}
\todo{Splitten und jeden Abschnitt einzeln erklären!}
Auch hier wird wieder ein Array mit möglichen ankommenden Befehlen definiert und der ankommende String gegen dieses Array geprüft. Kommt z.B. die Sequenz "@01" an, wird case 3 ausgewählt. Das Display zeigt Init an und sendet die Antwort die RapidForm erwartet zurück.\\
Die Sequenz "@0R" steht für eine Statusabfrage. Es wird eine Statusabfrage an die Schrittmotorkarte gesendet und der Status an RapidForm zurück gemeldet.
\lstset{language=C, basicstyle=\footnotesize, showstringspaces=false, tabsize=8}
\lstinputlisting[label=lst:switch_Isel,caption=Übersetzungs Logik: Isel]{Code/switch_Isel.txt}
\subsubsection{Weitere}
Es sind weitere Protokolle ansatzweise implementiert. Diese werden im allgemeinen jedoch nicht benötigt da nur das Isel und das Zeta Protokoll ordentlich in der Clientsoftware umgesetzt sind.